
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "gallery/plot_post_stack_inversion.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_gallery_plot_post_stack_inversion.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_gallery_plot_post_stack_inversion.py:


Post Stack Inversion - 3D
=========================
This illustration demonstrates the implementation of a distributed 3D Post-stack inversion. It involves
modelling a 3D synthetic post-stack seismic data from a 3D model of the subsurface acoustic impedence.

.. GENERATED FROM PYTHON SOURCE LINES 7-22

.. code-block:: default


    import numpy as np
    from scipy.signal import filtfilt
    from matplotlib import pyplot as plt
    from mpi4py import MPI

    from pylops.utils.wavelets import ricker
    from pylops.basicoperators import Transpose
    from pylops.avo.poststack import PoststackLinearModelling
    from pylops_mpi import MPIBlockDiag, DistributedArray

    plt.close("all")
    rank = MPI.COMM_WORLD.Get_rank()
    size = MPI.COMM_WORLD.Get_size()








.. GENERATED FROM PYTHON SOURCE LINES 23-25

Let's start by defining all of the parameters required by the
``pylops.avo.poststack.PoststackLinearModelling`` operator.

.. GENERATED FROM PYTHON SOURCE LINES 25-55

.. code-block:: default


    # Model
    model = np.load("../testdata/avo/poststack_model.npz")
    x, z, m = model['x'], model['z'], np.log(model['model'])

    # Making m a 3D model
    ny_i = 20  # size of model in y direction for rank i
    y = np.arange(ny_i)
    m3d_i = np.tile(m[:, :, np.newaxis], (1, 1, ny_i)).transpose((2, 1, 0))
    ny_i, nx, nz = m3d_i.shape

    # Size of y at all ranks
    ny = MPI.COMM_WORLD.allreduce(ny_i)

    # Smooth model
    nsmoothy, nsmoothx, nsmoothz = 5, 30, 20
    mback3d_i = filtfilt(np.ones(nsmoothy) / float(nsmoothy), 1, m3d_i, axis=0)
    mback3d_i = filtfilt(np.ones(nsmoothx) / float(nsmoothx), 1, mback3d_i, axis=1)
    mback3d_i = filtfilt(np.ones(nsmoothz) / float(nsmoothz), 1, mback3d_i, axis=2)

    # Wavelet
    dt = 0.004
    t0 = np.arange(nz) * dt
    ntwav = 41
    wav = ricker(t0[:ntwav // 2 + 1], 15)[0]

    # Collecting all the m3d and mback3d at all ranks
    m3d = np.concatenate(MPI.COMM_WORLD.allgather(m3d_i))
    mback3d = np.concatenate(MPI.COMM_WORLD.allgather(mback3d_i))








.. GENERATED FROM PYTHON SOURCE LINES 56-66

We now create the linear operator version of
``pylops.avo.poststack.PostStackLinearModelling`` at each rank to model a
subset of the data along the y-axis. Such operators are passes
to the ``pylops_mpi.MPIBlockDiag`` operator, which is then used to perform
the different forward operations of each individual operator
at different ranks to compute the overall data. Note that to simplify the
handling of the model and data, we split and distribute the first axis,
and use ``pylops.basicoperators.Transpose`` to rearrange the model and data
in the form required by the ``pylops.avo.poststack.PostStackLinearModelling``
operator

.. GENERATED FROM PYTHON SOURCE LINES 66-121

.. code-block:: default


    # Create flattened model data
    m3d_dist = DistributedArray(global_shape=ny * nx * nz)
    m3d_dist[:] = m3d_i.flatten()

    # LinearOperator PostStackLinearModelling
    PPop = PoststackLinearModelling(wav, nt0=nz, spatdims=(ny_i, nx))
    Top = Transpose((ny_i, nx, nz), (2, 0, 1))
    BDiag = MPIBlockDiag(ops=[Top.H @ PPop @ Top, ])

    # Data
    d_dist = BDiag @ m3d_dist
    d_local = d_dist.local_array.reshape((ny_i, nx, nz))
    d = d_dist.asarray().reshape((ny, nx, nz))

    if rank == 0:
        # Check the distributed implementation gives the same result
        # as the one running only on rank0
        PPop0 = PoststackLinearModelling(wav, nt0=nz, spatdims=(ny, nx))
        d0 = (PPop0 @ m3d.transpose(2, 0, 1)).transpose(1, 2, 0)

        # Check the two distributed implementations give the same result
        print('Distr == Local', np.allclose(d, d0))

        # Visualize
        fig, axs = plt.subplots(nrows=3, ncols=3, figsize=(9, 12), constrained_layout=True)
        axs[0][0].imshow(m3d[5, :, :].T, cmap="gist_rainbow", vmin=m.min(), vmax=m.max())
        axs[0][0].set_title("Model x-z")
        axs[0][0].axis("tight")
        axs[0][1].imshow(m3d[:, 400, :].T, cmap="gist_rainbow", vmin=m.min(), vmax=m.max())
        axs[0][1].set_title("Model y-z")
        axs[0][1].axis("tight")
        axs[0][2].imshow(m3d[:, :, 220].T, cmap="gist_rainbow", vmin=m.min(), vmax=m.max())
        axs[0][2].set_title("Model y-z")
        axs[0][2].axis("tight")

        axs[1][0].imshow(mback3d[5, :, :].T, cmap="gist_rainbow", vmin=m.min(), vmax=m.max())
        axs[1][0].set_title("Smooth Model x-z")
        axs[1][0].axis("tight")
        axs[1][1].imshow(mback3d[:, 400, :].T, cmap="gist_rainbow", vmin=m.min(), vmax=m.max())
        axs[1][1].set_title("Smooth Model y-z")
        axs[1][1].axis("tight")
        axs[1][2].imshow(mback3d[:, :, 220].T, cmap="gist_rainbow", vmin=m.min(), vmax=m.max())
        axs[1][2].set_title("Smooth Model y-z")
        axs[1][2].axis("tight")

        axs[2][0].imshow(d[5, :, :].T, cmap="gray", vmin=-1, vmax=1)
        axs[2][0].set_title("Data x-z")
        axs[2][0].axis("tight")
        axs[2][1].imshow(d[:, 400, :].T, cmap='gray', vmin=-1, vmax=1)
        axs[2][1].set_title('Data y-z')
        axs[2][1].axis('tight')
        axs[2][2].imshow(d[:, :, 220].T, cmap='gray', vmin=-1, vmax=1)
        axs[2][2].set_title('Data x-y')
        axs[2][2].axis('tight')



.. image-sg:: /gallery/images/sphx_glr_plot_post_stack_inversion_001.png
   :alt: Model x-z, Model y-z, Model y-z, Smooth Model x-z, Smooth Model y-z, Smooth Model y-z, Data x-z, Data y-z, Data x-y
   :srcset: /gallery/images/sphx_glr_plot_post_stack_inversion_001.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Distr == Local True





.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 0 minutes  10.105 seconds)


.. _sphx_glr_download_gallery_plot_post_stack_inversion.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example




    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: plot_post_stack_inversion.py <plot_post_stack_inversion.py>`

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: plot_post_stack_inversion.ipynb <plot_post_stack_inversion.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
