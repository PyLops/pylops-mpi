
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "tutorials/benchmarking.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_tutorials_benchmarking.py>`
        to download the full example code.

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_tutorials_benchmarking.py:


Benchmark Utility in PyLops-MPI
===============================
This tutorial demonstrates how to use the :py:func:`pylops_mpi.utils.benchmark` and
:py:func:`pylops_mpi.utils.mark` utility methods in PyLops-MPI. It contains various
function calling pattern that may come up during the benchmarking of a distributed code.

:py:func:`pylops_mpi.utils.benchmark` is a decorator used to decorate any
function to measure its execution time from start to finish
:py:func:`pylops_mpi.utils.mark` is a function used inside the benchmark-decorated
function to provide fine-grain time measurements.

.. GENERATED FROM PYTHON SOURCE LINES 13-27

.. code-block:: Python


    import sys
    import logging
    import numpy as np
    from mpi4py import MPI
    from pylops_mpi import DistributedArray, Partition

    np.random.seed(42)
    rank = MPI.COMM_WORLD.Get_rank()

    par = {'global_shape': (500, 501),
           'partition': Partition.SCATTER, 'dtype': np.float64,
           'axis': 1}








.. GENERATED FROM PYTHON SOURCE LINES 28-29

Let's start by import the utility and a simple exampple

.. GENERATED FROM PYTHON SOURCE LINES 29-41

.. code-block:: Python

    from pylops_mpi.utils.benchmark import benchmark, mark


    @benchmark
    def inner_func(par):
        dist_arr = DistributedArray(global_shape=par['global_shape'],
                                    partition=par['partition'],
                                    dtype=par['dtype'], axis=par['axis'])
        # may perform computation here
        dist_arr.dot(dist_arr)









.. GENERATED FROM PYTHON SOURCE LINES 42-47

When we call :py:func:`inner_func`, we will see the result
of the benchmark print to standard output. If we want to customize the
function name in the printout, we can pass the parameter `description`
to the :py:func:`benchmark`
i.e., :py:func:`@benchmark(description="printout_name")`

.. GENERATED FROM PYTHON SOURCE LINES 47-50

.. code-block:: Python


    inner_func(par)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    /opt/hostedtoolcache/Python/3.11.14/x64/lib/python3.11/site-packages/pylops_mpi/DistributedArray.py:598: RuntimeWarning: overflow encountered in dot
      ncp.dot(x.local_array.flatten(), y.local_array.flatten()),
    /opt/hostedtoolcache/Python/3.11.14/x64/lib/python3.11/site-packages/pylops_mpi/DistributedArray.py:598: RuntimeWarning: invalid value encountered in dot
      ncp.dot(x.local_array.flatten(), y.local_array.flatten()),
    [decorator]inner_func: total runtime: 0.002325 s





.. GENERATED FROM PYTHON SOURCE LINES 51-53

We may want to get the fine-grained time measurements by timing the execution
time of arbitary lines of code. :py:func:`pylops_mpi.utils.mark` provides such utitlity.

.. GENERATED FROM PYTHON SOURCE LINES 53-66

.. code-block:: Python



    @benchmark
    def inner_func_with_mark(par):
        mark("Begin array constructor")
        dist_arr = DistributedArray(global_shape=par['global_shape'],
                                    partition=par['partition'],
                                    dtype=par['dtype'], axis=par['axis'])
        mark("Begin dot")
        dist_arr.dot(dist_arr)
        mark("Finish dot")









.. GENERATED FROM PYTHON SOURCE LINES 67-70

Now when we run, we get the detailed time measurement. Note that there is a tag
[decorator] next to the function name to distinguish between the start-to-end time
measurement of the top-level function and those that comes from :py:func:`pylops_mpi.utils.mark`

.. GENERATED FROM PYTHON SOURCE LINES 70-72

.. code-block:: Python

    inner_func_with_mark(par)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    [decorator]inner_func_with_mark: total runtime: 0.000347 s
            Begin array constructor-->Begin dot: 0.000061 s
            Begin dot-->Finish dot: 0.000282 s





.. GENERATED FROM PYTHON SOURCE LINES 73-75

This utility benchmarking routines can also be nested. Let's define
an outer function that internally calls the decorated :py:func:`inner_func_with_mark`

.. GENERATED FROM PYTHON SOURCE LINES 75-88

.. code-block:: Python



    @benchmark
    def outer_func_with_mark(par):
        mark("Outer func start")
        inner_func_with_mark(par)
        dist_arr = DistributedArray(global_shape=par['global_shape'],
                                    partition=par['partition'],
                                    dtype=par['dtype'], axis=par['axis'])
        dist_arr + dist_arr
        mark("Outer func ends")









.. GENERATED FROM PYTHON SOURCE LINES 89-91

If we run :py:func:`outer_func_with_mark`, we get the time measurement nicely
printed out with the nested indentation to specify that nested calls.

.. GENERATED FROM PYTHON SOURCE LINES 91-94

.. code-block:: Python

    outer_func_with_mark(par)






.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    /opt/hostedtoolcache/Python/3.11.14/x64/lib/python3.11/site-packages/pylops_mpi/DistributedArray.py:550: RuntimeWarning: overflow encountered in add
      SumArray[:] = self.local_array + dist_array.local_array
    /opt/hostedtoolcache/Python/3.11.14/x64/lib/python3.11/site-packages/pylops_mpi/DistributedArray.py:550: RuntimeWarning: invalid value encountered in add
      SumArray[:] = self.local_array + dist_array.local_array
    [decorator]outer_func_with_mark: total runtime: 0.000848 s
            [decorator]inner_func_with_mark: total runtime: 0.000328 s
                    Begin array constructor-->Begin dot: 0.000023 s
                    Begin dot-->Finish dot: 0.000303 s
            Outer func start-->Outer func ends: 0.000845 s





.. GENERATED FROM PYTHON SOURCE LINES 95-100

In some cases, we may want to write benchmark output to a text file.
:py:func:`pylops_mpi.utils.benchmark` also takes the py:class:`logging.Logger`
in its argument.
Here we define a simple :py:func:`make_logger()`. We set the :py:func:`logger.propagate = False`
to isolate the logging of our benchmark from that of the rest of the code

.. GENERATED FROM PYTHON SOURCE LINES 100-120

.. code-block:: Python


    save_file = True
    file_path = "benchmark.log"


    def make_logger(save_file=False, file_path=''):
        logger = logging.getLogger(__name__)
        logging.basicConfig(filename=file_path if save_file else None, filemode='w', level=logging.INFO, force=True)
        logger.propagate = False
        if save_file:
            handler = logging.FileHandler(file_path, mode='w')
        else:
            handler = logging.StreamHandler(sys.stdout)
        logger.addHandler(handler)
        return logger


    logger = make_logger(save_file, file_path)









.. GENERATED FROM PYTHON SOURCE LINES 121-122

Then we can pass the logger to the :py:func:`pylops_mpi.utils.benchmark`

.. GENERATED FROM PYTHON SOURCE LINES 122-132

.. code-block:: Python


    @benchmark(logger=logger)
    def inner_func_with_logger(par):
        dist_arr = DistributedArray(global_shape=par['global_shape'],
                                    partition=par['partition'],
                                    dtype=par['dtype'], axis=par['axis'])
        # may perform computation here
        dist_arr.dot(dist_arr)









.. GENERATED FROM PYTHON SOURCE LINES 133-134

Run this function and observe that the file `benchmark.log` is written.

.. GENERATED FROM PYTHON SOURCE LINES 134-135

.. code-block:: Python

    inner_func_with_logger(par)








.. rst-class:: sphx-glr-timing

   **Total running time of the script:** (0 minutes 0.007 seconds)


.. _sphx_glr_download_tutorials_benchmarking.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: benchmarking.ipynb <benchmarking.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: benchmarking.py <benchmarking.py>`

    .. container:: sphx-glr-download sphx-glr-download-zip

      :download:`Download zipped: benchmarking.zip <benchmarking.zip>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
